# Brood
### Neural Surrogate Controller Learning (Apis – Step 2)

## Overview

**Brood** is the second step in the **Apis** project.

Its purpose is to **learn a neural surrogate of a flight controller purely from data**, without access to the controller’s internal structure, gains, or implementation.

Brood operates entirely *offline* on datasets generated by **Nuc**.  
It does not run controllers in real time, and it does not interact directly with simulators or hardware.

---

## Position in Apis

Apis is structured as a sequence of steps:

1. **Nuc** – deterministic simulation and controller-in-the-loop data generation  
2. **Brood** – neural surrogate controller learning  
3. Waggle – Unity-based scaffolding  
4. Propolis – Isaac Sim integration  
5. Scopa – virtual sensor expansion  
6. Proboscis – perception → policy pipelines  

Brood depends on **Nuc** and produces artifacts that inform later steps, but it is intentionally **isolated** from visualization and real-time control concerns.

---

## Core Goal

The goal of Brood is:

> **Given only observed behavior of a controller in closed loop, learn a neural approximation that reproduces that behavior.**

This mirrors real-world situations where:
- the true controller is closed-source,
- only input/output telemetry is available,
- reimplementation or direct reuse is impossible.

---

## What Is Being Learned

Brood does **not** learn:
- quadcopter physics,
- motor mixing,
- stabilization loops,
- state estimation.

Instead, Brood learns a mapping of the form:

```
(state, reference) → control_command
```

Where:
- `state` is the observed system state (as logged by Nuc),
- `reference` is the commanded target (position, velocity, etc.),
- `control_command` is the controller’s output (e.g. roll*, pitch*, thrust*, yaw-rate*).

The learned model is treated as a **surrogate controller**, not as a policy in an RL sense.

---

## Data Source

All training data used by Brood comes from **Nuc**.

Typical logged signals include:
- position, velocity
- attitude (roll/pitch/yaw)
- reference signals
- controller outputs
- timestamps and metadata

Brood assumes:
- fixed time steps
- deterministic logs
- clean separation between reference and response

No Unity or Isaac Sim data is required at this stage.

---

## Learning Paradigm

Brood uses **supervised learning**, not reinforcement learning.

Key characteristics:
- behavioral cloning of a controller
- regression, not reward optimization
- no environment interaction during training

This allows:
- fast iteration
- stable training
- clear diagnostics when models fail

---

## Implementation Approach

### Language and Tools
- **Python** for data handling
- **JAX** for:
  - automatic differentiation
  - vectorized computation
  - JIT compilation
  - GPU/CPU flexibility

The choice of JAX is intentional:
- gradients are explicit and cheap,
- batch rollouts are efficient,
- models remain differentiable end-to-end.

---

## Training Structure

A typical Brood experiment consists of:

1. Dataset loading and normalization  
2. Model definition (MLP or structured network)  
3. Loss definition (e.g. MSE on control outputs)  
4. Training loop (gradient-based optimization)  
5. Validation on held-out trajectories  

Optionally:
- closed-loop rollout using the learned surrogate
- stability and divergence analysis

---

## Evaluation Criteria

Brood does not evaluate success by loss alone.

Key questions include:
- Does the surrogate remain stable in closed loop?
- Does it respect implicit constraints (saturation, coupling)?
- Does it generalize to unseen trajectories?
- Where and how does it fail?

Failures are considered **informative**, not errors.

---

## Explicit Non-Goals

Brood does **not** aim to:
- outperform the original controller
- replace real flight software
- fly a real drone
- guarantee safety or stability

It is an **analytical and exploratory step**, not a deployment path.

---

## Relationship to Later Steps

Outputs of Brood may be used to:
- compare learned vs engineered controllers,
- test learned controllers in simulation (carefully),
- inform action-space design for later autonomy stacks.

However, Brood is intentionally decoupled from:
- Unity (Waggle),
- Isaac Sim (Propolis),
- sensor modeling (Scopa),
- perception pipelines (Proboscis).

---

## Philosophy

> **Brood is about understanding what learning can copy — and what it cannot.**  
> It treats controllers as behaviors, not code.  
> Stability is observed, not assumed.

Brood exists to make the limits of learning *visible*.
